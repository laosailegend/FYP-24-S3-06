"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LambdaBuildCli = exports.META_FILE_NAME = exports.ZIP_FILE_NAME = void 0;
const chalk_1 = __importDefault(require("chalk"));
exports.ZIP_FILE_NAME = 'archive.zip';
exports.META_FILE_NAME = 'meta.json';
class LambdaBuildCli {
    constructor(fsys, output, lambdaBuildCore) {
        this.fsys = fsys;
        this.output = output;
        this.lambdaBuildCore = lambdaBuildCore;
        this.commandArchive = (options) => __awaiter(this, void 0, void 0, function* () {
            try {
                this.output.log();
                this.output.log(chalk_1.default.bold(' ️⚡️ Bundling %s'), options.entry);
                if (options.external.length) {
                    this.output.log(chalk_1.default.dim('  → Excluding %s'), options.external.join(','));
                }
                const res = yield this.lambdaBuildCore.bundleAndArchive(options.entry, options.external, options.metafile);
                if (res.meta && options.metafile) {
                    yield this.fsys.writeFile(exports.META_FILE_NAME, res.meta);
                    this.output.log(chalk_1.default.dim('  → Generated %s'), exports.META_FILE_NAME);
                }
                if (res.archive) {
                    yield this.fsys.writeFile(exports.ZIP_FILE_NAME, res.archive);
                    this.output.log(chalk_1.default.green.bold('  ✔ Created %s') + chalk_1.default.dim.green(' %s'), exports.ZIP_FILE_NAME, res.archiveSize);
                }
                this.output.log();
            }
            catch (err) {
                this.outputErrors(err);
            }
        });
        this.publishAndLog = (region, functionName, archive) => __awaiter(this, void 0, void 0, function* () {
            this.output.log(chalk_1.default.dim('  → Uploading %s'), functionName);
            const arn = yield this.lambdaBuildCore.publishLambda(region, functionName, archive);
            if (arn) {
                this.output.log(chalk_1.default.white('  ✔ Successfully uploaded %s'), functionName);
            }
            return arn;
        });
        this.commandUpload = (options) => __awaiter(this, void 0, void 0, function* () {
            try {
                this.output.log();
                this.output.log(chalk_1.default.bold(' ⚡️ Bundling & Uploading %s'), options.entry);
                if (options.external.length) {
                    this.output.log(chalk_1.default.dim('  → Excluding %s'), options.external.join(','));
                }
                const res = yield this.lambdaBuildCore.bundleAndArchive(options.entry, options.external, options.metafile);
                this.output.log(chalk_1.default.green.dim('  → Bundle archived %s'), res.archiveSize);
                if (res.meta) {
                    yield this.fsys.writeFile(exports.META_FILE_NAME, res.meta);
                    this.output.log(chalk_1.default.dim('  → Generated %s'), exports.META_FILE_NAME);
                }
                if (res.archive && options.lambdas && options.region) {
                    this.output.log(chalk_1.default.dim('  → Using region %s'), options.region);
                    const all = [];
                    for (const lambda of options.lambdas) {
                        all.push(this.publishAndLog(options.region, lambda, res.archive));
                    }
                    const arns = yield Promise.all(all);
                    const uploadedArns = arns.filter(arn => Boolean(arn));
                    this.output.log(chalk_1.default.green.bold('  ✔ Successfully uploaded %s function(s)'), uploadedArns.length);
                }
                this.output.log();
            }
            catch (err) {
                this.outputErrors(err);
            }
        });
        this.outputErrors = (err) => {
            this.output.log();
            this.output.log(chalk_1.default.bold.underline.red(`Errors:`));
            if (err instanceof Error) {
                this.output.log(err.message);
            }
            else {
                this.output.log(err);
            }
            this.output.log();
        };
    }
}
exports.LambdaBuildCli = LambdaBuildCli;
